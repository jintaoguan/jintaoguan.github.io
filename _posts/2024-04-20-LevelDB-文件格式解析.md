---
layout:     post
title:      LevelDB 数据格式解析(1)
date:       2024-04-20
author:     Jintao
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - LevelDB
---

## 概述
在 LevelDB 中存在各种类型的数据，每一种数据都使用了特定的存储格式，并且这些格式都被其他的数据库引擎继承并扩展，比如 Facebook 开发的的 RocksDB，又比如 CockroachDB 在使用的单机存储引擎 pebble，它们使用的都是 LevelDB 的文件格式。所以学习并理解 LevelDB 的数据格式以及为什么这样设计有助于我们对于这些存储引擎源码的学习。我们知道 LevelDB 是一种基于 operation log 的存储系统，是 Log-Structured-Merge Tree 的典型实现。我们会介绍 LevelDB 中使用多种数据格式，比如各种 Key 的表示，日志文件 (Write-Ahead-Log)，SSTable 文件，MemTable 与跳表 (Skiplist) 等等。

## LevelDB 基本数据结构

#### Slice
Slice 是 Leveldb中的基本数据结构，包括 length 和一个指向外部字节数组的指针。和 string 一样，允许字符串中包含 ’\0’。提供一些基本接口，可以把 const char 和 string 转换为 Slice，把 Slice 转换为 string，取得数据指针 const char。
~~~c++
class LEVELDB_EXPORT Slice {
  public:
    // public methods
  private:
    const char* data_;
    size_t size_;
};
~~~

#### Status
Status 是 Leveldb 中的返回状态，将错误号和错误信息封装成 Status 类，统一进行处理。并定义了几种具体的返回状态，如成功或者文件不存在等。为了节省空间 Status 并没有用 std::string 来存储错误信息，而是将返回码 (code), 错误信息 message 及长度打包存储于一个字符串数组中。成功状态 OK 是 NULL state_，否则 state_ 是一个包含如下信息的数组:

~~~c++
state_[0..3] // 消息message长度 
state_[4]    // 消息code
state_[5..]  // 消息message 
~~~

#### Arena
Arena 是 LevelDB 的简单的内存池，它所作的工作十分简单，申请内存时，将申请到的内存块放入 std::vector blocks_ 中，在 Arena 的生命周期结束后，统一释放掉所有申请到的内存，Arena没有直接调用 delete/free 函数，而是由 Arena 的析构函数统一释放所有的内存。

#### Skiplist
Skiplist (跳表) 是一种可以代替平衡树的数据结构。Skiplist 应用概率保证平衡，平衡树采用严格的旋转（比如平衡二叉树有左旋右旋）来保证平衡，因此 Skiplist 比较容易实现，而且相比平衡树有着较高的运行效率。从概率上保持数据结构的平衡比显式的保持数据结构平衡要简单的多。对于大多数应用，用 skiplist 要比用树更自然，算法也会相对简单。由于 skiplist 比较简单，实现起来会比较容易，虽然和平衡树有着相同的时间复杂度 (O(logn))，但是skiplist的常数项相对小很多。skiplist 在空间上也比较节省。一个节点平均只需要1.333个指针（甚至更少），并且不需要存储保持平衡的变量。

## 各类 Key 的结构
LevelDB 是一个 Key-Value 存储，但是在 LevelDB 中对于 Key 有多种不同形式的表示与存储结构。

#### User Key, InternalKey 和 ParsedInternalKey 
`User Key`也就是用户定义的，任意长度内容的 Key，用来读取之前写入数据库的 Value。
`InternalKey` 是一个复合概念，是有几个部分组合成的一个key，`ParsedInternalKey`就是对`InternalKey`分拆后的结果，先来看看`ParsedInternalKey`的成员，这是一个struct
~~~c++
typedef uint64_t SequenceNumber;
enum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };

struct ParsedInternalKey {
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;
}
~~~
也就是说 `InternalKey` 是由 (`User Key` + `Sequence Number` + `Value Type`) 组合而成的，顺便先分析下几个 Key 相关的函数，它们是了解Internal Key 和 User Key 的关键。
~~~c++
class InternalKey {
  public:
    // public methods
  private:
    std::string rep_;
}
~~~

从`InternalKey`的定义可以看到，它只有一个变量`rep_`，存储的就是一段 byte array。有以下两个方法可以进行的转换。
~~~c++
// 解析 InternalKey （一段字节数组）并转换成 ParsedInternalKey
bool ParseInternalKey(const Slice& internal_key, ParsedInternalKey* result) {
  const size_t n = internal_key.size();
  if (n < 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  uint8_t c = num & 0xff;
  result->sequence = num >> 8;
  result->type = static_cast<ValueType>(c);
  result->user_key = Slice(internal_key.data(), n - 8);
  return (c <= static_cast<uint8_t>(kTypeValue));
}

// 将 ParsedInternalKey 转换成字节数组，并写到 result 里
void AppendInternalKey (std::string* result, const ParsedInternalKey& key) {
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}
// 将 ParsedInternalKey 的 SequenceNumber 和 ValueType 组合成最后 8 个连续字节
static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  assert(seq <= kMaxSequenceNumber);
  assert(t <= kValueTypeForSeek);
  return (seq << 8) | t;
}
~~~

根据这两个方法的实现，容易得到`InternalKey`的格式（即`rep_`数据的格式）。

**InternalKey 的格式**：
```
| User Key (string) | Sequence Number (7 bytes) | Value Type (1 byte) |
```

值得注意的是，`User Key`是任意长度的，但是这个`InternalKey`中是**不存储 User Key 的长度的**。我猜原因是`InternalKey`只用于内存中表示 Key，往往用 Slice 进行表示，而不需要序列化到磁盘上或者从磁盘反序列化到内存中，所以不需要记录长度信息。
由此还可知道sequence number大小是7 bytes，sequence number是所有基于op log系统的关键数据，它唯一指定了不同操作的时间顺序。

把`User Key`放到**前面**的原因是，这样对同一个 user key 的操作就可以按照 sequence number 顺序连续存放了。另外用户可以为 user key 定制比较函数，系统默认是字母序的。如果按照默认字母序进行排序的话，相同的 user key 的操作 (不同的 sequence number 和 value type) 会被放在一起。

#### LookupKey 和 Memtable Key
首先我们来了解 `LookupKey`。MemTable 的查询接口传入的是`LookupKey`，它也是由 User Key 和 Sequence Number 组合而成的。

**LookupKey 的格式**：
```
| Size (Varint32) | User Key (string) | Sequence Number (7 bytes) | Value Type (1 byte) |
```

可以看出这里`LookupKey`和之前`InternalKey`的唯一区别就是`LookupKey`在头部用 Varint32 变长方法**存储了后面的 InternalKey 的长度**，大约占用 1 到 5 个字节。这里的 Size 是 **(user_key.size() + 8)**，也就是对应的 InternalKey 的长度了。另外这里 value type 是`kValueTypeForSeek`，它等于`kTypeValue`。LookupKey的定义如下：
~~~c++
class LookupKey {
  public:
    // public methods
  private:
    // We construct a char array of the form:
    //    klength  varint32               <-- start_
    //    userkey  char[klength]          <-- kstart_
    //    tag      uint64                 <-- 8 bytes: sequence + type
    //                                    <-- end_
    // The array is a suitable MemTable key.
    // The suffix starting with "userkey" can be used as an InternalKey.
    const char* start_;
    const char* kstart_;
    const char* end_;
    char space_[200];  // Avoid allocation for short keys
};

LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);   // klength = user_key.size() + 8 
  kstart_ = dst;
  std::memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}
~~~

LookupKey 导出了三个函数，可以分别从 LookupKey 得到 Internal Key，Memtable Key 和 User Key，如下：
~~~c++
// Return a key suitable for lookup in a MemTable.
Slice memtable_key() const { return Slice(start_, end_ - start_); }

// Return an internal key (suitable for passing to an internal iterator)
Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

// Return the user key
Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }
~~~

从上面`memtable_key()`方法的实现可以看出来，`LookupKey`和`Memtable Key`其实表达的是相同的概念。

## 日志文件格式
日志文件是 LevelDB 也是所有  Log-Structured-Merge Tree 数据库的重要组成部分。所有的写操作都必须先成功的append到操作日志中，然后再更新内存memtable。这样做有两点好处：
- 可以将**随机写**变成**顺序写**，极大的提高写的速度；
- 在节点down机后，内存数据消失，系统可以在重启后根据日志恢复内存数据继续服务，从而避免内存数据丢失。

LevelDB将日志文件按照 32KB 的 Block 进行分块操作，每次读取的单位也是以一个 Block 作为基本读取单位（以 block 为基本单位读取的好处是什么？）。阅读源码后可知，Log 文件由以下层级构成：
- 每个`Log文件`包含多个`Block`，每个 Block (32 KB)。
- 每个`Block`包含多条`Log`， Log 可以为完整的一条，也可以是不完整的（前半部分/后半部分/中间部分），因为 Block 是固定 32 KB
- 每条`Log`数据由`header`和`data`构成。
- `header`长度是固定的 7 bytes，由 CRC（4 bytes）, Log length（2 bytes），Log type （1 byte）构成。
- `data`是任意长度。

**单条 Log 数据格式**：
```
| CRC (4 bytes) | Length (2 bytes) | Type (1 byte) | Data |
```

Header 中的这个占用一个字节的`type`是什么呢？我们知道 Block 是固定 32 KB，而 Log 的长度是任意的（因为用户的 Key 和 Value 长度是任意的），所以一个 Block 有可能存放多条完整的 Log，也有可能存放不完整的 Log（前半部分/后半部分/中间部分），所以`type`用来标记这个一条完整的 Log 还是一条不完整的 Log，如果是不完整的 Log，那么它是前半部分，后半部分还是中间部分？
~~~c++
namespace log {
enum RecordType {
  // Zero is reserved for preallocated files
  kZeroType = 0,

  kFullType = 1,

  // For fragments
  kFirstType = 2,
  kMiddleType = 3,
  kLastType = 4
};
static const int kMaxRecordType = kLastType;
static const int kBlockSize = 32768;
// Header is checksum (4 bytes), length (2 bytes), type (1 byte).
static const int kHeaderSize = 4 + 2 + 1;
}
~~~

因为 Log 的 header 就占用了 7 bytes，那么当一个 Block 在存放完上一条 Log 之后只剩下 6 bytes 或者更少时，就不再继续使用当前 Block，并且使用`'\0'`填充剩下的空间，所以在 Block 最后最多可以看到 **6个连续的 '\0'**。

**Log 文件格式**：
![](/img/post-img/2024-04-20/leveldb_log_format.png)


## SSTable 文件格式


## MemTable 格式


# 参考
* [Dremel: Interactive Analysis of Web-Scale Datasets](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf)

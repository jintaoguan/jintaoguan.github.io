---
layout:     post
title:      LevelDB 数据格式解析(1)
date:       2024-04-20
author:     Jintao
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - LevelDB
---

## 概述
在 LevelDB 中存在各种类型的数据，每一种数据都使用了特定的存储格式，并且这些格式都被其他的数据库引擎继承并扩展，比如 Facebook 开发的的 RocksDB，又比如 CockroachDB 在使用的单机存储引擎 pebble。所以学习并理解 LevelDB 的数据格式以及为什么这样设计有助于我们对于这些存储引擎源码的学习。我们知道 LevelDB 是一种基于 operation log 的文件系统，是 Log-Structured-Merge Tree 的典型实现。我们会介绍 LevelDB 中使用多种数据格式，比如日志文件 (Write-Ahead-Log)，SSTable 文件，MemTable 与跳表 (Skiplist) 等等。

## LevelDB 基本数据结构

#### Slice
Slice 是 Leveldb中的基本数据结构，包括 length 和一个指向外部字节数组的指针。和 string 一样，允许字符串中包含 ’\0’。提供一些基本接口，可以把 const char 和 string 转换为 Slice，把 Slice 转换为 string，取得数据指针 const char。
~~~c++
class LEVELDB_EXPORT Slice {
  public:
    // public methods
  private:
    const char* data_;
    size_t size_;
};
~~~

#### Status
Status 是 Leveldb 中的返回状态，将错误号和错误信息封装成 Status 类，统一进行处理。并定义了几种具体的返回状态，如成功或者文件不存在等。为了节省空间 Status 并没有用 std::string 来存储错误信息，而是将返回码 (code), 错误信息 message 及长度打包存储于一个字符串数组中。成功状态 OK 是 NULL state_，否则 state_ 是一个包含如下信息的数组:

~~~c++
state_[0..3] // 消息message长度 
state_[4]    // 消息code
state_[5..]  // 消息message 
~~~

#### Arena
Arena 是 LevelDB 的简单的内存池，它所作的工作十分简单，申请内存时，将申请到的内存块放入 std::vector blocks_ 中，在 Arena 的生命周期结束后，统一释放掉所有申请到的内存，Arena没有直接调用 delete/free 函数，而是由 Arena 的析构函数统一释放所有的内存。

#### Skiplist
Skiplist (跳表) 是一种可以代替平衡树的数据结构。Skiplist 应用概率保证平衡，平衡树采用严格的旋转（比如平衡二叉树有左旋右旋）来保证平衡，因此 Skiplist 比较容易实现，而且相比平衡树有着较高的运行效率。从概率上保持数据结构的平衡比显式的保持数据结构平衡要简单的多。对于大多数应用，用 skiplist 要比用树更自然，算法也会相对简单。由于 skiplist 比较简单，实现起来会比较容易，虽然和平衡树有着相同的时间复杂度 (O(logn))，但是skiplist的常数项相对小很多。skiplist 在空间上也比较节省。一个节点平均只需要1.333个指针（甚至更少），并且不需要存储保持平衡的变量。

## 各类 Key 的结构
LevelDB 是一个 Key-Value 存储，但是在 LevelDB 中对于 Key 有多种不同形式的表示与存储结构。

#### User Key, InternalKey 和 ParsedInternalKey 
`User Key`也就是用户定义的，任意长度内容的 Key，用来读取之前写入数据库的 Value。
`InternalKey` 是一个复合概念，是有几个部分组合成的一个key，`ParsedInternalKey`就是对`InternalKey`分拆后的结果，先来看看`ParsedInternalKey`的成员，这是一个struct
~~~c++
typedef uint64_t SequenceNumber;
enum ValueType { kTypeDeletion = 0x0, kTypeValue = 0x1 };

struct ParsedInternalKey {
  Slice user_key;
  SequenceNumber sequence;
  ValueType type;
}
~~~
也就是说 `InternalKey` 是由 (`User Key` + `Sequence Number` + `Value Type`) 组合而成的，顺便先分析下几个 Key 相关的函数，它们是了解Internal Key 和 User Key 的关键。
~~~c++
class InternalKey {
  public:
    // public methods
  private:
    std::string rep_;
}
~~~

从`InternalKey`的定义可以看到，它只有一个变量`rep_`，存储的就是一段 byte array。有以下两个方法可以进行的转换。
~~~c++
// 解析 InternalKey （一段字节数组）并转换成 ParsedInternalKey
bool ParseInternalKey(const Slice& internal_key, ParsedInternalKey* result) {
  const size_t n = internal_key.size();
  if (n < 8) return false;
  uint64_t num = DecodeFixed64(internal_key.data() + n - 8);
  uint8_t c = num & 0xff;
  result->sequence = num >> 8;
  result->type = static_cast<ValueType>(c);
  result->user_key = Slice(internal_key.data(), n - 8);
  return (c <= static_cast<uint8_t>(kTypeValue));
}

// 将 ParsedInternalKey 转换成字节数组，并写到 result 里
void AppendInternalKey (std::string* result, const ParsedInternalKey& key) {
  result->append(key.user_key.data(), key.user_key.size());
  PutFixed64(result, PackSequenceAndType(key.sequence, key.type));
}
// 将 ParsedInternalKey 的 SequenceNumber 和 ValueType 组合成最后 8 个连续字节
static uint64_t PackSequenceAndType(uint64_t seq, ValueType t) {
  assert(seq <= kMaxSequenceNumber);
  assert(t <= kValueTypeForSeek);
  return (seq << 8) | t;
}
~~~

根据这两个方法的实现，容易得到`InternalKey`的格式（即`rep_`数据的格式）。

**InternalKey 的格式**：
```
| User Key (string) | Sequence Number (7 bytes) | Value Type (1 byte) |
```

值得注意的是，`User Key`是任意长度的，但是这个`InternalKey`中是**不存储 User Key 的长度的**。我猜原因是`InternalKey`只用于内存中表示 Key，往往用 Slice 进行表示，而不需要序列化到磁盘上或者从磁盘反序列化到内存中，所以不需要记录长度信息。
由此还可知道sequence number大小是7 bytes，sequence number是所有基于op log系统的关键数据，它唯一指定了不同操作的时间顺序。

把`User Key`放到**前面**的原因是，这样对同一个 user key 的操作就可以按照 sequence number 顺序连续存放了。另外用户可以为 user key 定制比较函数，系统默认是字母序的。如果按照默认字母序进行排序的话，相同的 user key 的操作 (不同的 sequence number 和 value type) 会被放在一起。

#### LookupKey 和 Memtable Key
首先我们来了解 `LookupKey`。MemTable的查询接口传入的是`LookupKey`，它也是由 User Key 和 Sequence Number组合而成的。

**LookupKey 的格式**：
```
| Size (int32变长)| User Key (string) | Sequence Number (7 bytes) | Value Type (1 byte) |
```

可以看出这里`LookupKey`和之前`InternalKey`的唯一区别就是`LookupKey`在头部用 int32 变长方法**存储了后面的 InternalKey 的长度**。这里的 Size 是 **(user_key.size() + 8)**，也就是对应的 InternalKey 的长度了。另外这里 value type 是`kValueTypeForSeek`，它等于`kTypeValue`。LookupKey的定义如下：
~~~c++
class LookupKey {
  public:
    // public methods
  private:
    // We construct a char array of the form:
    //    klength  varint32               <-- start_
    //    userkey  char[klength]          <-- kstart_
    //    tag      uint64                 <-- 8 bytes: sequence + type
    //                                    <-- end_
    // The array is a suitable MemTable key.
    // The suffix starting with "userkey" can be used as an InternalKey.
    const char* start_;
    const char* kstart_;
    const char* end_;
    char space_[200];  // Avoid allocation for short keys
};

LookupKey::LookupKey(const Slice& user_key, SequenceNumber s) {
  size_t usize = user_key.size();
  size_t needed = usize + 13;  // A conservative estimate
  char* dst;
  if (needed <= sizeof(space_)) {
    dst = space_;
  } else {
    dst = new char[needed];
  }
  start_ = dst;
  dst = EncodeVarint32(dst, usize + 8);   // klength = user_key.size() + 8 
  kstart_ = dst;
  std::memcpy(dst, user_key.data(), usize);
  dst += usize;
  EncodeFixed64(dst, PackSequenceAndType(s, kValueTypeForSeek));
  dst += 8;
  end_ = dst;
}
~~~

LookupKey 导出了三个函数，可以分别从 LookupKey 得到 Internal Key，Memtable Key 和 User Key，如下：
~~~c++
// Return a key suitable for lookup in a MemTable.
Slice memtable_key() const { return Slice(start_, end_ - start_); }

// Return an internal key (suitable for passing to an internal iterator)
Slice internal_key() const { return Slice(kstart_, end_ - kstart_); }

// Return the user key
Slice user_key() const { return Slice(kstart_, end_ - kstart_ - 8); }
~~~

从上面`memtable_key()`方法的实现可以看出来，`LookupKey`和`Memtable Key`其实表达的是相同的概念。

## 日志文件 Write-Ahead-Log

## SSTable 文件

## MemTable 


# 参考
* [Dremel: Interactive Analysis of Web-Scale Datasets](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/36632.pdf)
